var searchIndex = JSON.parse('{\
"ocr_lang":{"doc":"OCR-lang is an interpreter for OCR Exam Reference, the …","t":[0,0,0,5,0,5,0,3,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,3,4,13,11,11,11,11,11,11,11,5,11,11,12,12,11,11,11,11,11,11,3,11,11,11,12,12,11,11,11,11,12,12,11,11,11,3,11,11,11,12,12,11,11,11,11,12,11,11,11,11,11,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,4,13,13,11,11,11,11,11,11,11,11,12,12,12,12],"n":["args","error","lexer","ocr_lang_main","position","setup_logging","token","Args","augment_args","augment_args_for_update","borrow","borrow_mut","command","command_for_update","filename","from","from_arg_matches","from_arg_matches_mut","group_id","into","try_from","try_into","type_id","update_from_arg_matches","update_from_arg_matches_mut","Error","ErrorKind","IOError","borrow","borrow","borrow_mut","borrow_mut","fmt","from","from","handle_error","into","into","kind","msg","try_from","try_from","try_into","try_into","type_id","type_id","Lexer","advance","borrow","borrow_mut","current_char","filename","from","into","lex","new","pos","stream","try_from","try_into","type_id","Position","advance","borrow","borrow_mut","column","filename","fmt","fmt","from","into","line","start","to_string","try_from","try_into","type_id","And","Array","AssignEq","ByRef","ByVal","Case","Class","Colon","Comma","Div","Do","Dot","Else","ElseIf","EndClass","EndFunction","EndIf","EndProcedure","EndSwitch","EndWhile","EqTo","Exp","FloatLiteral","FloorDiv","For","Function","Ge","Global","Gt","Identifier","If","Inherits","IntegerLiteral","LParen","LSquareParen","Le","Lt","Minus","Mod","Mul","Ne","New","Next","Not","Or","Plus","Private","Procedure","Public","RParen","RSquareParen","Return","StringLiteral","Switch","Then","To","Token","Until","While","borrow","borrow_mut","fmt","from","into","try_from","try_into","type_id","0","0","0","0"],"q":["ocr_lang","","","","","","","ocr_lang::args","","","","","","","","","","","","","","","","","","ocr_lang::error","","","","","","","","","","","","","","","","","","","","","ocr_lang::lexer","","","","","","","","","","","","","","","ocr_lang::position","","","","","","","","","","","","","","","","ocr_lang::token","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","ocr_lang::token::Token","","",""],"d":["","","","The main function for this program. Parses arguments, …","","Initialise logging. Copy-pasted from Fern docs","","","","","","","","","File to run. If not given, defaults to stdin, which does …","Returns the argument unchanged.","","","","Calls <code>U::from(self)</code>.","","","","","","Struct to represent an error","Enum to represent the diferent kinds of errors","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Prints the error nicely to the console and exits with code …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","Struct to transform input into <code>Token</code>s","Advance the <code>Lexer</code>. Reads one byte from the input stream …","","","Character that we are currently processing","The file name that we are lexing","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Transform into <code>Vec&lt;Token&gt;</code>. Returns <code>Err</code> if we could not …","Create a new <code>Lexer</code>","Our position in the text we are lexing","Stream that we are reading our input from","","","","Struct to represent the position we are at in the text we …","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Enum for tokens","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","",""],"i":[0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,10,13,10,13,10,10,13,10,0,13,10,13,13,13,10,13,10,13,10,0,14,14,14,14,14,14,14,14,14,14,14,14,14,14,0,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,0,16,16,16,16,16,16,16,16,16,16,23,24,25,26],"f":[0,0,0,[[]],0,[[],[[2,[1]]]],0,0,[3,3],[3,3],[[]],[[]],[[],3],[[],3],0,[[]],[4,[[2,[5,6]]]],[4,[[2,[5,6]]]],[[],[[8,[7]]]],[[]],[[],2],[[],2],[[],9],[[5,4],[[2,[6]]]],[[5,4],[[2,[6]]]],0,0,0,[[]],[[]],[[]],[[]],[[10,11],12],[[]],[[]],[13],[[]],[[]],0,0,[[],2],[[],2],[[],2],[[],2],[[],9],[[],9],0,[14,15],[[]],[[]],0,0,[[]],[[]],[14,[[2,[[17,[16]],13]]]],[[[19,[18]],20],14],0,0,[[],2],[[],2],[[],9],0,[[21,22]],[[]],[[]],0,0,[[21,11],12],[[21,11],12],[[]],[[]],0,[20,21],[[],20],[[],2],[[],2],[[],9],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[16,11],12],[[]],[[]],[[],2],[[],2],[[],9],0,0,0,0],"p":[[4,"InitError"],[4,"Result"],[3,"Command"],[3,"ArgMatches"],[3,"Args"],[6,"Error"],[3,"Id"],[4,"Option"],[3,"TypeId"],[4,"ErrorKind"],[3,"Formatter"],[6,"Result"],[3,"Error"],[3,"Lexer"],[6,"Result"],[4,"Token"],[3,"Vec"],[8,"Read"],[3,"Box"],[3,"String"],[3,"Position"],[15,"char"],[13,"Identifier"],[13,"StringLiteral"],[13,"IntegerLiteral"],[13,"FloatLiteral"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
